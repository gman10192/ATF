//stateManager.cpp

//STATE MANAGER
//Based on PackML v3.0 Mode & States document.

//Used tutorial from: http://www.cplusplus.com/doc/tutorial/classes/ 
 
 

#include "stateManager.h"

//StateManagerClass::StateManagerClass(byte a, byte b, byte c) : _requestedState(a), _currentState(b), _previousState(c) {}
	//Class constrcutor, only executed once upon the creation of an object of this class type.
	//i.e.  StateManagerClass stateManager(0,0,0)

StateManagerClass::StateManagerClass() {
	//Class default constrcutor, only executed once upon the creation of an object of this class type and only used if no values are sent when creating the object
	//i.e. StateManagerClass stateManager{}
	_requestedState = 0;
	_currentState = ABORTED;
	_previousState = 0;
}


void StateManagerClass::transitionTo(byte _tempState){
	//Accepts request to transition to the specified state and determines if that is acceptable and then allows the state change.
	//**NOTE**: Only code to verify it is approrpriate to transition to requested state should be here.
	//Actual actions and machine operation will be handled by state modules: functions for the corresponding state (i.e. stateStarting, stateResetting, etc.)
	//Any faults generated by an attempt to transition from one state to another should be handled in the individual state modules.

	_requestedState = _tempState;
	
	switch (_requestedState) {
	case IDLE:
		if (_currentState == RESETTING) {
			_previousState = _currentState;
			_currentState = IDLE;
			genie.WriteObject(GENIE_OBJ_STRINGS, 0, IDLE);
		}
		else {//FAULT
			_previousState = _currentState;
			_currentState = FAULTED;
			gFault = TRUE;
			gFaultMessage = 6;  //Unable to enter requested IDLE state
		}
		break;
	case STARTING:
		if (_currentState == IDLE) {
			_previousState = _currentState;
			_currentState = STARTING;
			genie.WriteObject(GENIE_OBJ_STRINGS, 0, STARTING);
			stateStarting();
		}
		else if (_currentState == WAITING) {
			_previousState = _currentState;
			_currentState = STARTING;
			genie.WriteObject(GENIE_OBJ_STRINGS, 0, STARTING);
		}
		else { _currentState = _currentState; }
		break;
	case EXECUTE:
		break;
	case COMPLETING:
		break;
	case COMPLETE:
		break;
	case HOLDING:
		break;
	case HELD:
		break;
	case UNHOLDING:
		if (_currentState == STARTING) {
			break;
		}
		else if () {
		}
		break;
	case PAUSING:
		break;
	case PAUSED:
		break;
	case UNPAUSING:
		break;
	case RESETTING:
		if (_currentState == MANUAL_MODE || _currentState == CONFIGURATION || _currentState == STOPPED) {
			_previousState = _currentState;
			_currentState = RESETTING;
			genie.WriteObject(GENIE_OBJ_STRINGS, 0, RESETTING);
			stateResetting();
		}
		else {//FAULT
			_previousState = _currentState;
			_currentState = FAULTED;
			gFault = TRUE;
			gFaultMessage = 7;  //Unable to enter requested RESETTING state
		}
		break;
	case STOPPED:
		break;
	case STOPPING:
		break;
	case ABORTED:
		break;
	case ABORTING:
		break;
	case CONFIGURATION:  //Enter Settings screen
		if (_currentState == IDLE) {
			genie.WriteObject(GENIE_OBJ_FORM, 3, 0);  //Activate Settings screen on the display
			_currentState = CONFIGURATION;
			genie.WriteObject(GENIE_OBJ_STRINGS, 0, CONFIGURATION);
		}
		break;
	case MANUAL_MODE:
		if (_currentState == IDLE) {
			genie.WriteObject(GENIE_OBJ_FORM, 4, 0);  //Activate manual mode screen on the display
			_currentState = MANUAL_MODE;
			genie.WriteObject(GENIE_OBJ_STRINGS, 0, MANUAL_MODE);
		}
		break;
	case FAULTED:  //Not sure if I need this state in here or not...
		break;
	case WAITING:
		_previousState = _currentState;
		_currentState = WAITING;
		genie.WriteObject(GENIE_OBJ_STRINGS, 0, WAITING);
		stateWaiting();
		break;
	case DONE_WAITING:
		if (_currentState == WAITING) {
			_previousState = _currentState;
			_currentState = DONE_WAITING;
			genie.WriteObject(GENIE_OBJ_STRINGS, 0, DONE_WAITING);
		}
		else {//FAULT
			_previousState = _currentState;
			_currentState = FAULTED;
			gFault = TRUE;
			gFaultMessage = 11;  //Unable to enter requested DONE WAITING state
		}
	default://FAULT
		gFaultMessage = 5;
		_currentState = FAULTED;
		break;
	}
}

void StateManagerClass::immediateTransitionTo(byte _requestedState){
	//Force state transitioto the state indicated, to heck with it all
}

byte StateManagerClass::getCurrentState(void){
	//Request the current state of the system - returns a byte
	
	return byte();
}

bool StateManagerClass::isInState(byte _instate)
{
	if (_instate == _currentState){return TRUE;}
	else{return FALSE;}
}

void StateManagerClass::update(void) {
	//Tell the state manager to update its self

}





StateManagerClass StateManager;



//if (gCurrentState == IDLE && gRequestedState == STARTING) scenario = 1;  //Start PB
//if (gCurrentState == RESETTING && gRequestedState == IDLE) scenario = 2;
//if (gCurrentState == STOPPED && gRequestedState == RESETTING) scenario = 3;  //Reset PB
//if (gCurrentState == STOPPING && gRequestedState == STOPPED) scenario = 4;
//if (gCurrentState == CLEARING && gRequestedState == STOPPED) scenario = 5;
//if (gCurrentState == ABORTED && gRequestedState == CLEARING) scenario = 6;
//if (gCurrentState == ABORTING && gRequestedState == ABORTED) scenario = 7;
//if (gCurrentState == STARTING && gRequestedState == EXECUTE) scenario = 8;
//if (gCurrentState == EXECUTE && gRequestedState == COMPLETING) scenario = 9;
//if (gCurrentState == COMPLETING && gRequestedState == COMPLETE) scenario = 10;
//if (gCurrentState == EXECUTE && gRequestedState == HOLDING) scenario = 11;  //Hold PB
//if (gCurrentState == HOLDING && gRequestedState == HELD) scenario = 12;
//if (gCurrentState == HELD && gRequestedState == UNHOLDING) scenario = 13;  //Resume PB
//if (gCurrentState == UNHOLDING && gRequestedState == EXECUTE) scenario = 14;
//if (gCurrentState == EXECUTE && gRequestedState == PAUSING) scenario = 15;  //Suspend PB
//if (gCurrentState == PAUSING && gRequestedState == PAUSED) scenario = 16;
//if (gCurrentState == PAUSED && gRequestedState == UNPAUSING) scenario = 17;  //Resume PB
//if (gCurrentState == UNPAUSING && gRequestedState == EXECUTE) scenario = 18;
//if ((gCurrentState >= 1 && gCurrentState <= 12) && gRequestedState == STOPPING) scenario = 19; //Stop PB
//if ((gCurrentState >= 1 && gCurrentState <= 15) && gRequestedState == ABORTING) scenario = 20;  //Abort PB
//if (gCurrentState == IDLE && gRequestedState == CONFIGURATION) scenario = 21;  //Configure Mode
//if (gCurrentState == CONFIGURATION && gRequestedState == RESETTING) scenario = 22;  //Reset PB
//if (gCurrentState == IDLE && gRequestedState == MANUAL_MODE) scenario = 23;  //Manual Mode
//if (gCurrentState == MANUAL_MODE && gRequestedState == RESETTING) scenario = 24; //Reset PB