//stateManager.cpp

//STATE MANAGER
//Based on PackML v3.0 Mode & States document.
 
 

#include "stateManager.h"

void StateManagerClass::init(){
	
}



void StateManagerClass::transitionTo(byte requestedState){
	//Accepts request to transition to the specified state and determines if that is acceptable and then allows the state change.
	//**NOTE**: Only code to verify it is approrpriate to transition to requested state should be here.
	//Actual actions and machine operation will be handled by state modules: functions for the corresponding state (i.e. stateStarting, stateResetting, etc.)
	//Any faults generated by an attempt to transition from one state to another should be handled in the individual state modules.
	switch (requestedState) {
	case IDLE:
		if (gPreviousState == RESETTING && gResetComplete == TRUE) {
			gPreviousState = gCurrentState;
			gCurrentState = IDLE;
			genie.WriteObject(GENIE_OBJ_STRINGS, 0, IDLE);
			gResetComplete = FALSE;
		}
		else {
			gFault = TRUE;
			gFaultMessage = 6;  //Unable to enter requested IDLE state
		}
		break;
	case STARTING:
		if (gCurrentState == IDLE) {
			gPreviousState = gCurrentState;
			gCurrentState = STARTING;
			genie.WriteObject(GENIE_OBJ_STRINGS, 0, STARTING);
			stateStarting();
		}
		else
			gCurrentState = gCurrentState;
		break;
	case EXECUTE:
		break;
	case COMPLETING:
		//Do whatever for scenario
		break;
	case COMPLETE:
		//Do whatever for scenario
		break;
	case HOLDING:
		//Do whatever for scenario
		break;
	case HELD:
		//Do whatever for scenario
		break;
	case UNHOLDING:
		if (gCurrentState == STARTING) {
			break;
		}
		else if () {
		}
		break;
	case SUSPENDING:
		//Do whatever for scenario
		break;
	case SUSPENDED:
		//Do whatever for scenario
		break;
	case UNSUSPENDING:
		//Do whatever for scenario
		break;
	case RESETTING:
		if (gCurrentState == MANUAL_MODE || gCurrentState == CONFIGURATION || gCurrentState == STOPPED) {
			gPreviousState = gCurrentState;
			gCurrentState = RESETTING;
			genie.WriteObject(GENIE_OBJ_STRINGS, 0, RESETTING);
			stateResetting();
		}
		else {
			gFault = TRUE;
			gFaultMessage = 7;  //Unable to enter requested RESETTING state
		}
		break;
	case STOPPED:
		//Do whatever for scenario
		break;
	case STOPPING:
		//Do whatever for scenario
		break;
	case CLEARING:
		//Do whatever for scenario
		break;
	case ABORTED:
		//Do whatever for scenario
		break;
	case ABORTING:
		//Do whatever for scenario
		break;
	case CONFIGURATION:  //Enter Settings screen
		if (gCurrentState == IDLE) {
			genie.WriteObject(GENIE_OBJ_FORM, 3, 0);  //Activate Settings screen on the display
			gCurrentState = CONFIGURATION;
			genie.WriteObject(GENIE_OBJ_STRINGS, 0, CONFIGURATION);
		}
		break;
	case MANUAL_MODE:
		if (gCurrentState == IDLE) {
			genie.WriteObject(GENIE_OBJ_FORM, 4, 0);  //Activate manual mode screen on the display
			gCurrentState = MANUAL_MODE;
			genie.WriteObject(GENIE_OBJ_STRINGS, 0, MANUAL_MODE);
		}
		break;
	case FAULTED:  //Not sure if I need this state in here or not...
				   //??
		break;
	default:
		gFaultMessage = 5;
		gCurrentState = FAULTED;
		break;
	}
}

void StateManagerClass::immediateTransitionTo(byte _requestedState){
	//Force state transitioto the state indicated, to heck with it all
}

byte StateManagerClass::getCurrentState(void){
	//Request the current state of the system - returns a byte
	
	return byte();
}

void StateManagerClass::update(void) {
	//Tell the state manager to update its self

}





StateManagerClass StateManager;

